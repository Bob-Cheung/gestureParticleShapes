<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ - æœ€ç»ˆç‰ˆ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Segoe UI', sans-serif;
    }

    /* 3D ç”»å¸ƒ */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* æ‘„åƒå¤´è¾“å…¥æº (éšè—ï¼šåªä¾› MediaPipe å†…éƒ¨è¯»å–) */
    /* ã€å·²ä¿®æ”¹ã€‘éšè—åŸå§‹è§†é¢‘æµï¼Œè§£å†³åŒé‡ç”»é¢é—®é¢˜ */
    .input_video {
      display: none;
    }

    /* éª¨éª¼ç»˜åˆ¶ Canvas (è¿™æ˜¯ç”¨æˆ·å”¯ä¸€çœ‹åˆ°çš„ç”»é¢) */
    .output_canvas {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 320px;
      /* ã€å·²ä¿®æ”¹ã€‘æ”¾å¤§æ˜¾ç¤ºå°ºå¯¸ */
      height: 240px;
      border-radius: 10px;
      opacity: 0.8;
      transform: scaleX(-1);
      /* é•œåƒ */
      z-index: 2;
      border: 2px solid rgba(255, 255, 255, 0.2);
      display: none;
      /* åˆå§‹éšè—ï¼Œç­‰å¾… JS å¼€å¯ */
    }

    /* UI é¢æ¿ */
    #ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      width: 280px;
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
    }

    h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
      letter-spacing: 1px;
      color: #00d2ff;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      font-size: 12px;
      margin-bottom: 5px;
      color: #aaa;
    }

    /* æ ·å¼åŒ–æ§ä»¶ */
    select,
    input[type="color"] {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      outline: none;
    }

    option {
      background: #222;
    }

    button {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg, #00d2ff, #3a7bd5);
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
    }

    button:hover {
      transform: scale(1.02);
    }

    button.active {
      background: linear-gradient(90deg, #ff416c, #ff4b2b);
    }

    .status {
      font-size: 10px;
      margin-top: 10px;
      color: #666;
      text-align: center;
    }

    /* åŠ è½½æŒ‡ç¤ºå™¨ */
    #loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00d2ff;
      font-size: 20px;
      z-index: 20;
      pointer-events: none;
    }
  </style>
</head>

<body>

  <video class="input_video" playsinline></video>

  <canvas class="output_canvas"></canvas>

  <div id="canvas-container"></div>

  <div id="loader">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰å¼•æ“...</div>

  <div id="ui-panel">
    <h2>âœ¨ ç²’å­äº¤äº’æ§åˆ¶å°</h2>

    <div class="control-group">
      <label>ç²’å­æ¨¡å‹å½¢çŠ¶</label>
      <select id="shape-select">
        <option value="heart">â¤ï¸ 3D çˆ±å¿ƒ</option>
        <option value="saturn">ğŸª åœŸæ˜Ÿå…‰ç¯</option>
        <option value="fireworks">ğŸ† çƒŸèŠ±çˆ†ç‚¸</option>
        <option value="torus">ğŸŒ€ å¤æ‚ç»³ç»“</option>
        <option value="sphere">ğŸŒ é‡å­çƒä½“</option>
      </select>
    </div>

    <div class="control-group">
      <label>ç²’å­é¢œè‰²</label>
      <input type="color" id="color-picker" value="#00d2ff">
    </div>

    <div class="control-group">
      <button id="cam-toggle">å¼€å¯æ‘„åƒå¤´äº¤äº’</button>
    </div>

    <div class="status" id="status-text">ç­‰å¾…æ‘„åƒå¤´å¼€å¯...</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    // --- 1. Three.js åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
    // ã€æœ€ç»ˆå€¼ã€‘35000 é«˜å¯†åº¦ç²’å­
    const particleCount = 35000;

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);

    // åˆå§‹åŒ–ä½ç½®
    for (let i = 0; i < particleCount * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 100;
      targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // åŠ¨æ€ç”Ÿæˆçº¹ç†
    const getSprite = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 32; canvas.height = 32;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, 32, 32);
      return canvas;
    };

    const material = new THREE.PointsMaterial({
      // ã€æœ€ç»ˆå€¼ã€‘0.25 ç»†è…»å°ºå¯¸
      size: 0.25,
      color: 0x00d2ff,
      map: new THREE.CanvasTexture(getSprite()),
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true,
      opacity: 0.9
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
    function calculateShape(shapeType) {
      for (let i = 0; i < particleCount; i++) {
        let x, y, z;

        if (shapeType === 'heart') {
          const t = Math.random() * Math.PI * 2;
          x = 16 * Math.pow(Math.sin(t), 3);
          y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          z = (Math.random() - 0.5) * 5;
          const scale = Math.random();
          x *= scale; y *= scale; z *= scale;
        }
        else if (shapeType === 'sphere') {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          const r = 10 + Math.random() * 2;
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
        }
        else if (shapeType === 'saturn') {
          const isRing = Math.random() > 0.4;
          if (isRing) {
            const theta = Math.random() * Math.PI * 2;
            const r = 12 + Math.random() * 8;
            x = r * Math.cos(theta);
            z = r * Math.sin(theta);
            y = (Math.random() - 0.5) * 0.5;
          } else {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 6;
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta);
            z = r * Math.cos(phi);
          }
        }
        else if (shapeType === 'torus') {
          const u = Math.random() * Math.PI * 2;
          const v = Math.random() * Math.PI * 2;
          const r = 8 + Math.random();
          const p = 2, q = 3;
          x = (r + Math.cos(q * u)) * Math.cos(p * u);
          y = (r + Math.cos(q * u)) * Math.sin(p * u);
          z = Math.sin(q * u) * 4;
        }
        else if (shapeType === 'fireworks') {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          const r = Math.random() * 25;
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
        }

        targetPositions[i * 3] = x || 0;
        targetPositions[i * 3 + 1] = y || 0;
        targetPositions[i * 3 + 2] = z || 0;
      }
    }

    // åˆå§‹å½¢çŠ¶
    calculateShape('sphere');

    // --- 4. äº¤äº’é€»è¾‘çŠ¶æ€ ---
    let handOpenFactor = 0; // 0 = å‡èš, 1 = æ‰©æ•£
    let isCameraActive = false;
    let isHandDetected = false;

    // UI äº‹ä»¶ç›‘å¬ (ä¿æŒä¸å˜)
    document.getElementById('shape-select').addEventListener('change', (e) => {
      calculateShape(e.target.value);
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
      material.color.set(e.target.value);
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 5. åŠ¨ç”»å¾ªç¯ ---
    function animate() {
      requestAnimationFrame(animate);

      // è‡ªåŠ¨æ—‹è½¬ (æ— æ‰‹åŠ¿æ§åˆ¶ç‰ˆæœ¬)
      scene.rotation.y += 0.002;
      scene.rotation.z += 0.0005;

      // ç²’å­è¿åŠ¨é€»è¾‘
      const positionsArray = particles.geometry.attributes.position.array;

      // ã€æœ€ç»ˆå€¼ã€‘æ‰©æ•£å€æ•° 2.5
      let expansion = 1 + (handOpenFactor * 2.5);
      const speed = 0.2; // ã€æœ€ç»ˆå€¼ã€‘ç²’å­é£è¡Œé€Ÿåº¦ (é«˜å“åº”)

      for (let i = 0; i < particleCount; i++) {
        const px = positionsArray[i * 3];
        const py = positionsArray[i * 3 + 1];
        const pz = positionsArray[i * 3 + 2];

        const tx = targetPositions[i * 3] * expansion;
        const ty = targetPositions[i * 3 + 1] * expansion;
        const tz = targetPositions[i * 3 + 2] * expansion;

        // ç¼“åŠ¨å‡½æ•°
        positionsArray[i * 3] += (tx - px) * speed;
        positionsArray[i * 3 + 1] += (ty - py) * speed;
        positionsArray[i * 3 + 2] += (tz - pz) * speed;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      renderer.render(scene, camera);
    }
    animate();


    // --- 6. MediaPipe æ‰‹åŠ¿è¯†åˆ«é›†æˆ ---
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const toggleButton = document.getElementById('cam-toggle');
    const statusText = document.getElementById('status-text');
    const loader = document.getElementById('loader');

    let cameraUtils = null;
    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // --- MediaPipe å›è°ƒ (éª¨éª¼ç»˜åˆ¶ä¸äº¤äº’) ---
    function onResults(results) {
      loader.style.display = 'none';

      // ç»˜åˆ¶éª¨éª¼
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.scale(-1, 1);
      canvasCtx.translate(-canvasElement.width, 0);
      // åœ¨ Canvas ä¸Šç»˜åˆ¶è§†é¢‘å¸§
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        isHandDetected = true;
        const landmarks = results.multiHandLandmarks[0];

        // ç»˜åˆ¶æ‰‹éƒ¨éª¨éª¼å’Œå…³é”®ç‚¹
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 3 });
        drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 1, radius: 2 });

        // æ‰©æ•£/å‡èšé€»è¾‘
        const thumbTip = landmarks[4];
        const pinkyTip = landmarks[20];

        const distance = Math.sqrt(
          Math.pow(thumbTip.x - pinkyTip.x, 2) +
          Math.pow(thumbTip.y - pinkyTip.y, 2)
        );

        let factor = (distance - 0.05) * 3.5;
        factor = Math.max(0, Math.min(1, factor));

        // ã€æœ€ç»ˆå€¼ã€‘æ‰‹åŠ¿å¹³æ»‘åº¦ (é«˜å“åº” 0.4)
        handOpenFactor += (factor - handOpenFactor) * 0.4;

        statusText.innerText = "ğŸ™Œ æ£€æµ‹åˆ°æ‰‹åŠ¿ | æ‰©æ•£åº¦: " + Math.round(handOpenFactor * 100) + "%";

      } else {
        isHandDetected = false;
        // æ‰‹æ¶ˆå¤±æ—¶ï¼Œå¿«é€Ÿå›å¼¹
        handOpenFactor += (0 - handOpenFactor) * 0.2;
        statusText.innerText = "ğŸ‘€ å¯»æ‰¾æ‰‹æŒä¸­...";
      }

      canvasCtx.restore();
    }

    // æ‘„åƒå¤´å¼€å…³é€»è¾‘
    toggleButton.addEventListener('click', () => {
      if (!isCameraActive) {
        statusText.innerText = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
        toggleButton.innerText = "å…³é—­æ‘„åƒå¤´";
        toggleButton.classList.add('active');

        // åªæ˜¾ç¤º Canvas å…ƒç´ 
        canvasElement.style.display = "block";

        // ã€æœ€ç»ˆå€¼ã€‘è®¾ç½® Canvas å°ºå¯¸ä¸º 320x240
        canvasElement.width = 320;
        canvasElement.height = 240;

        cameraUtils = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement });
          },
          width: 640,
          height: 480
        });
        cameraUtils.start();
        isCameraActive = true;
      } else {
        location.reload();
      }
    });

    loader.style.display = 'none';
    toggleButton.addEventListener('click', () => {
      if (isCameraActive) loader.style.display = 'block';
    });

  </script>
</body>

</html>